digraph cluster0dot {
	graph [compound=True fontname="DejaVu Sans Mono" label=dot pack=False rankdir=TB ranksep=0.02]
	node [fontname="DejaVu Sans Mono"]
	edge [fontname="DejaVu Sans Mono"]
	1 [label="\"\"\"\lThis module provides two implementations for the rod-cutting problem:\l1. A naive recursive implementation which has an exponential runtime\l2. Two dynamic programming implementations which have quadratic runtime\lThe rod-cutting problem is the problem of finding the maximum possible revenue\lobtainable from a rod of length ``n`` given a list of prices for each integral piece\lof the rod. The maximum revenue can thus be obtained by cutting the rod and selling the\lpieces separately or not cutting it at all if the price of it is the maximum obtainable.\l\"\"\"\ldef naive_cut_rod_recursive(n: int, prices: list):...\ldef top_down_cut_rod(n: int, prices: list):...\ldef _top_down_cut_rod_recursive(n: int, prices: list, max_rev: list):...\ldef bottom_up_cut_rod(n: int, prices: list):...\ldef _enforce_args(n: int, prices: list):...\ldef main():...\l" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
	86 [label="if __name__ == '__main__':\l" fillcolor="#FF6752" shape=diamond style="filled,solid"]
	87 [label="main()\l" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
	87 -> 89 [label=calls style=dashed]
	subgraph cluster_87 {
		graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		89 [label=main color="#E552FF" shape=tab style=filled]
	}
	86 -> 87 [label="__name__ == '__main__'" color=green]
	1 -> 86 [label="" color=black]
	subgraph cluster0naive_cut_rod_recursive {
		graph [compound=True fontname="DejaVu Sans Mono" label=naive_cut_rod_recursive pack=False rankdir=TB ranksep=0.02]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		3 [label="\"\"\"\l    Solves the rod-cutting problem via naively without using the benefit of dynamic\l    programming. The results is the same sub-problems are solved several times\l    leading to an exponential runtime\l    Runtime: O(2^n)\l    Arguments\l    -------\l    n: int, the length of the rod\l    prices: list, the prices for each piece of rod. ``p[i-i]`` is the\l    price for a rod of length ``i``\l    Returns\l    -------\l    The maximum revenue obtainable for a rod of length n given the list of prices\l    for each piece.\l    Examples\l    --------\l    >>> naive_cut_rod_recursive(4, [1, 5, 8, 9])\l    10\l    >>> naive_cut_rod_recursive(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])\l    30\l    \"\"\"\l_enforce_args(n, prices)\l" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		3 -> 4 [label=calls style=dashed]
		subgraph cluster_3 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			4 [label=_enforce_args color="#E552FF" shape=tab style=filled]
		}
		5 [label="if n == 0:\l" fillcolor="#FF6752" shape=diamond style="filled,solid"]
		6 [label="return 0\l" fillcolor="#98fb98" shape=parallelogram style="filled,solid"]
		5 -> 6 [label="n == 0" color=green]
		7 [label="max_revue = float('-inf')\l" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		7 -> 9 [label=calls style=dashed]
		subgraph cluster_7 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			9 [label=float color="#E552FF" shape=tab style=filled]
		}
		10 [label="for i in range(1, n + 1):\l" fillcolor="#FFBE52" shape=hexagon style="filled,solid"]
		10 -> 11 [label=calls style=dashed]
		subgraph cluster_10 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			11 [label=range color="#E552FF" shape=tab style=filled]
		}
		12 [label="max_revue = max(max_revue, prices[i - 1] + naive_cut_rod_recursive(n - i,\l    prices))\l" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		12 -> 14 [label=calls style=dashed]
		subgraph cluster_12 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			14 [label=max color="#E552FF" shape=tab style=filled]
			15 [label=naive_cut_rod_recursive color="#E552FF" shape=tab style=filled]
			14 -> 15 [color=black]
		}
		12 -> 10 [label="" color=black]
		10 -> 12 [label="range(1, n + 1)" color=green]
		13 [label="return max_revue\l" fillcolor="#98fb98" shape=parallelogram style="filled,solid"]
		10 -> 13 [label="" color=green]
		7 -> 10 [label="" color=black]
		5 -> 7 [label="(n != 0)" color=red]
		3 -> 5 [label="" color=black]
	}
	subgraph cluster0top_down_cut_rod {
		graph [compound=True fontname="DejaVu Sans Mono" label=top_down_cut_rod pack=False rankdir=TB ranksep=0.02]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		19 [label="\"\"\"\l    Constructs a top-down dynamic programming solution for the rod-cutting\l    problem via memoization. This function serves as a wrapper for\l    _top_down_cut_rod_recursive\l    Runtime: O(n^2)\l    Arguments\l    --------\l    n: int, the length of the rod\l    prices: list, the prices for each piece of rod. ``p[i-i]`` is the\l    price for a rod of length ``i``\l    Note\l    ----\l    For convenience and because Python's lists using 0-indexing, length(max_rev) =\l    n + 1, to accommodate for the revenue obtainable from a rod of length 0.\l    Returns\l    -------\l    The maximum revenue obtainable for a rod of length n given the list of prices\l    for each piece.\l    Examples\l    -------\l    >>> top_down_cut_rod(4, [1, 5, 8, 9])\l    10\l    >>> top_down_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])\l    30\l    \"\"\"\l_enforce_args(n, prices)\lmax_rev = [float('-inf') for _ in range(n + 1)]\l" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		19 -> 20 [label=calls style=dashed]
		19 -> 21 [label=calls style=dashed]
		19 -> 22 [label=calls style=dashed]
		subgraph cluster_19 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			20 [label=_enforce_args color="#E552FF" shape=tab style=filled]
			21 [label=float color="#E552FF" shape=tab style=filled]
			22 [label=range color="#E552FF" shape=tab style=filled]
		}
		23 [label="return _top_down_cut_rod_recursive(n, prices, max_rev)\l" fillcolor="#98fb98" shape=parallelogram style="filled,solid"]
		19 -> 23 [label="" color=black]
	}
	subgraph cluster0_top_down_cut_rod_recursive {
		graph [compound=True fontname="DejaVu Sans Mono" label=_top_down_cut_rod_recursive pack=False rankdir=TB ranksep=0.02]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		27 [label="\"\"\"\l    Constructs a top-down dynamic programming solution for the rod-cutting problem\l    via memoization.\l    Runtime: O(n^2)\l    Arguments\l    --------\l    n: int, the length of the rod\l    prices: list, the prices for each piece of rod. ``p[i-i]`` is the\l    price for a rod of length ``i``\l    max_rev: list, the computed maximum revenue for a piece of rod.\l    ``max_rev[i]`` is the maximum revenue obtainable for a rod of length ``i``\l    Returns\l    -------\l    The maximum revenue obtainable for a rod of length n given the list of prices\l    for each piece.\l    \"\"\"\l" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		28 [label="if max_rev[n] >= 0:\l" fillcolor="#FF6752" shape=diamond style="filled,solid"]
		29 [label="return max_rev[n]\l" fillcolor="#98fb98" shape=parallelogram style="filled,solid"]
		28 -> 29 [label="max_rev[n] >= 0" color=green]
		31 [label="if n == 0:\l" fillcolor="#FF6752" shape=diamond style="filled,solid"]
		32 [label="return 0\l" fillcolor="#98fb98" shape=parallelogram style="filled,solid"]
		31 -> 32 [label="n == 0" color=green]
		34 [label="max_revenue = float('-inf')\l" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		34 -> 35 [label=calls style=dashed]
		subgraph cluster_34 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			35 [label=float color="#E552FF" shape=tab style=filled]
		}
		36 [label="for i in range(1, n + 1):\l" fillcolor="#FFBE52" shape=hexagon style="filled,solid"]
		36 -> 37 [label=calls style=dashed]
		subgraph cluster_36 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			37 [label=range color="#E552FF" shape=tab style=filled]
		}
		38 [label="max_revenue = max(max_revenue, prices[i - 1] + _top_down_cut_rod_recursive(\l    n - i, prices, max_rev))\l" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		38 -> 40 [label=calls style=dashed]
		subgraph cluster_38 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			40 [label=max color="#E552FF" shape=tab style=filled]
			41 [label=_top_down_cut_rod_recursive color="#E552FF" shape=tab style=filled]
			40 -> 41 [color=black]
		}
		38 -> 36 [label="" color=black]
		36 -> 38 [label="range(1, n + 1)" color=green]
		39 [label="max_rev[n] = max_revenue\l" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		30 [label="return max_rev[n]\l" fillcolor="#98fb98" shape=parallelogram style="filled,solid"]
		39 -> 30 [label="" color=black]
		36 -> 39 [label="" color=green]
		34 -> 36 [label="" color=black]
		31 -> 34 [label="(n != 0)" color=red]
		28 -> 31 [label="(max_rev[n] < 0)" color=red]
		27 -> 28 [label="" color=black]
	}
	subgraph cluster0bottom_up_cut_rod {
		graph [compound=True fontname="DejaVu Sans Mono" label=bottom_up_cut_rod pack=False rankdir=TB ranksep=0.02]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		47 [label="\"\"\"\l    Constructs a bottom-up dynamic programming solution for the rod-cutting problem\l    Runtime: O(n^2)\l    Arguments\l    ----------\l    n: int, the maximum length of the rod.\l    prices: list, the prices for each piece of rod. ``p[i-i]`` is the\l    price for a rod of length ``i``\l    Returns\l    -------\l    The maximum revenue obtainable from cutting a rod of length n given\l    the prices for each piece of rod p.\l    Examples\l    -------\l    >>> bottom_up_cut_rod(4, [1, 5, 8, 9])\l    10\l    >>> bottom_up_cut_rod(10, [1, 5, 8, 9, 10, 17, 17, 20, 24, 30])\l    30\l    \"\"\"\l_enforce_args(n, prices)\lmax_rev = [float('-inf') for _ in range(n + 1)]\lmax_rev[0] = 0\l" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		47 -> 48 [label=calls style=dashed]
		47 -> 49 [label=calls style=dashed]
		47 -> 50 [label=calls style=dashed]
		subgraph cluster_47 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			48 [label=_enforce_args color="#E552FF" shape=tab style=filled]
			49 [label=float color="#E552FF" shape=tab style=filled]
			50 [label=range color="#E552FF" shape=tab style=filled]
		}
		51 [label="for i in range(1, n + 1):\l" fillcolor="#FFBE52" shape=hexagon style="filled,solid"]
		51 -> 52 [label=calls style=dashed]
		subgraph cluster_51 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			52 [label=range color="#E552FF" shape=tab style=filled]
		}
		53 [label="max_revenue_i = max_rev[i]\l" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		55 [label="for j in range(1, i + 1):\l" fillcolor="#FFBE52" shape=hexagon style="filled,solid"]
		55 -> 56 [label=calls style=dashed]
		subgraph cluster_55 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			56 [label=range color="#E552FF" shape=tab style=filled]
		}
		57 [label="max_revenue_i = max(max_revenue_i, prices[j - 1] + max_rev[i - j])\l" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		57 -> 59 [label=calls style=dashed]
		subgraph cluster_57 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			59 [label=max color="#E552FF" shape=tab style=filled]
		}
		57 -> 55 [label="" color=black]
		55 -> 57 [label="range(1, i + 1)" color=green]
		58 [label="max_rev[i] = max_revenue_i\l" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		58 -> 51 [label="" color=black]
		55 -> 58 [label="" color=green]
		53 -> 55 [label="" color=black]
		51 -> 53 [label="range(1, n + 1)" color=green]
		54 [label="return max_rev[n]\l" fillcolor="#98fb98" shape=parallelogram style="filled,solid"]
		51 -> 54 [label="" color=green]
		47 -> 51 [label="" color=black]
	}
	subgraph cluster0_enforce_args {
		graph [compound=True fontname="DejaVu Sans Mono" label=_enforce_args pack=False rankdir=TB ranksep=0.02]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		63 [label="\"\"\"\l    Basic checks on the arguments to the rod-cutting algorithms\l    n: int, the length of the rod\l    prices: list, the price list for each piece of rod.\l    Throws ValueError:\l    if n is negative or there are fewer items in the price list than the length of\l    the rod\l    \"\"\"\l" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		64 [label="if n < 0:\l" fillcolor="#FF6752" shape=diamond style="filled,solid"]
		65 [label="raise ValueError(f'n must be greater th...')\l" fillcolor="#98fb98" shape=house style="filled,solid"]
		64 -> 65 [label="n < 0" color=green]
		66 [label="if n > len(prices):\l" fillcolor="#FF6752" shape=diamond style="filled,solid"]
		66 -> 68 [label=calls style=dashed]
		subgraph cluster_66 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			68 [label=len color="#E552FF" shape=tab style=filled]
		}
		69 [label="raise ValueError(\l    f'Each integral piece ...'\l    )\l" fillcolor="#98fb98" shape=house style="filled,solid"]
		66 -> 69 [label="n > len(prices)" color=green]
		64 -> 66 [label="(n >= 0)" color=red]
		63 -> 64 [label="" color=black]
	}
	subgraph cluster0main {
		graph [compound=True fontname="DejaVu Sans Mono" label=main pack=False rankdir=TB ranksep=0.02]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		74 [label="prices = [6, 10, 12, 15, 20, 23]\ln = len(prices)\lexpected_max_revenue = 36\lmax_rev_top_down = top_down_cut_rod(n, prices)\lmax_rev_bottom_up = bottom_up_cut_rod(n, prices)\lmax_rev_naive = naive_cut_rod_recursive(n, prices)\lassert expected_max_revenue == max_rev_top_down\l" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		74 -> 75 [label=calls style=dashed]
		74 -> 76 [label=calls style=dashed]
		74 -> 77 [label=calls style=dashed]
		74 -> 78 [label=calls style=dashed]
		subgraph cluster_74 {
			graph [color=purple compound=true fontname="DejaVu Sans Mono" label="" rankdir=TB ranksep=0.02 shape=tab style=filled]
			node [fontname="DejaVu Sans Mono"]
			edge [fontname="DejaVu Sans Mono"]
			75 [label=len color="#E552FF" shape=tab style=filled]
			76 [label=top_down_cut_rod color="#E552FF" shape=tab style=filled]
			77 [label=bottom_up_cut_rod color="#E552FF" shape=tab style=filled]
			78 [label=naive_cut_rod_recursive color="#E552FF" shape=tab style=filled]
		}
		80 [label="assert max_rev_top_down == max_rev_bottom_up\l" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		81 [label="" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		80 -> 81 [label="(max_rev_top_down != max_rev_bottom_up)" color=black]
		82 [label="assert max_rev_bottom_up == max_rev_naive\l" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		83 [label="" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		82 -> 83 [label="(max_rev_bottom_up != max_rev_naive)" color=black]
		84 [label="" fillcolor="#FFFB81" shape=rectangle style="filled,solid"]
		82 -> 84 [label="max_rev_bottom_up == max_rev_naive" color=black]
		80 -> 82 [label="max_rev_top_down == max_rev_bottom_up" color=black]
		74 -> 80 [label="expected_max_revenue == max_rev_top_down" color=black]
	}
	subgraph cluster_KEY {
		graph [fontname="DejaVu Sans Mono" label=KEY]
		node [fontname="DejaVu Sans Mono"]
		edge [fontname="DejaVu Sans Mono"]
		input [fillcolor="#afeeee" shape=parallelogram style=filled]
		default [fillcolor="#FFFB81" shape=rectangle style=filled]
		if [fillcolor="#FF6752" shape=diamond style=filled]
		for [fillcolor="#FFBE52" shape=hexagon style=filled]
		while [fillcolor="#FFBE52" shape=hexagon style=filled]
		call [fillcolor="#E552FF" shape=tab style=filled]
		return [fillcolor="#98fb98" shape=parallelogram style=filled]
		try [fillcolor=orange shape=Mdiamond style=filled]
		raise [fillcolor="#98fb98" shape=house style=filled]
		if -> input [style=invis]
		input -> call [style=invis]
		for -> return [style=invis]
		return -> default [style=invis]
		try -> raise [style=invis]
	}
}
